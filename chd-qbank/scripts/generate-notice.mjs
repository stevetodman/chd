import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const repoRoot = path.resolve(projectRoot, '..');

const lockPath = path.join(projectRoot, 'package-lock.json');

function normalizeLicense(licenseField) {
  if (!licenseField) {
    return 'UNKNOWN';
  }

  if (typeof licenseField === 'string') {
    return licenseField;
  }

  if (Array.isArray(licenseField)) {
    return licenseField
      .map((entry) => normalizeLicense(entry))
      .filter(Boolean)
      .join(', ');
  }

  if (typeof licenseField === 'object') {
    return normalizeLicense(licenseField.type ?? licenseField.name ?? licenseField.license);
  }

  return 'UNKNOWN';
}

function formatAuthor(authorField) {
  if (!authorField) {
    return undefined;
  }

  if (typeof authorField === 'string') {
    return authorField;
  }

  const parts = [];
  if (authorField.name) {
    parts.push(authorField.name);
  }
  if (authorField.email) {
    parts.push(`<${authorField.email}>`);
  }
  if (authorField.url) {
    parts.push(authorField.url);
  }

  if (parts.length === 0) {
    return undefined;
  }

  return parts.join(' ');
}

function normalizeRepository(repositoryField) {
  if (!repositoryField) {
    return undefined;
  }

  if (typeof repositoryField === 'string') {
    return repositoryField.replace(/^git\+/, '');
  }

  if (typeof repositoryField === 'object' && repositoryField.url) {
    return repositoryField.url.replace(/^git\+/, '');
  }

  return undefined;
}

async function readJson(filePath) {
  try {
    const contents = await fs.readFile(filePath, 'utf8');
    return JSON.parse(contents);
  } catch (error) {
    if (error && error.code !== 'ENOENT') {
      console.warn(`Could not read ${filePath}:`, error);
    }
    return undefined;
  }
}

const lockContents = await fs.readFile(lockPath, 'utf8');
const lockData = JSON.parse(lockContents);
const packages = lockData.packages ?? {};
const dependencyMap = new Map();

for (const [pkgPath, pkgMeta] of Object.entries(packages)) {
  if (!pkgPath.startsWith('node_modules/')) {
    continue;
  }

  const name = pkgPath.replace(/^node_modules\//, '');
  const version = pkgMeta.version ?? 'UNKNOWN';
  const key = `${name}@${version}`;

  if (dependencyMap.has(key)) {
    continue;
  }

  const manifestPath = path.join(projectRoot, pkgPath, 'package.json');
  const manifest = await readJson(manifestPath);
  const license = normalizeLicense(pkgMeta.license ?? manifest?.license ?? manifest?.licenses);
  const author = formatAuthor(manifest?.author);
  const homepage = manifest?.homepage ?? normalizeRepository(manifest?.repository);

  dependencyMap.set(key, {
    name,
    version,
    license,
    author,
    homepage,
  });
}

const dependencies = Array.from(dependencyMap.values()).sort((a, b) => {
  return a.name.localeCompare(b.name) || a.version.localeCompare(b.version);
});

const inventoryDir = path.join(repoRoot, 'docs', 'compliance');
await fs.mkdir(inventoryDir, { recursive: true });
const inventoryPath = path.join(inventoryDir, 'license-inventory.json');

const existingInventory = await readJson(inventoryPath);
let generatedAt = new Date().toISOString();

if (existingInventory && Array.isArray(existingInventory.packages)) {
  const previousPackages = JSON.stringify(existingInventory.packages);
  const currentPackages = JSON.stringify(dependencies);

  if (previousPackages === currentPackages && typeof existingInventory.generatedAt === 'string') {
    generatedAt = existingInventory.generatedAt;
  }
}

const inventory = {
  generatedAt,
  packages: dependencies,
};

await fs.writeFile(inventoryPath, `${JSON.stringify(inventory, null, 2)}\n`, 'utf8');

const noticeHeader =
  `NOTICE\n` +
  `This project incorporates third-party dependencies. The following list identifies their licenses and primary sources.\n\n` +
  `This file is automatically generated via \`npm run notice\`. Do not edit manually.\n\n`;

const noticeBody = dependencies
  .map((dependency) => {
    const lines = [
      `- ${dependency.name}@${dependency.version}`,
      `  License: ${dependency.license}`,
    ];

    if (dependency.author) {
      lines.push(`  Publisher: ${dependency.author}`);
    }

    if (dependency.homepage) {
      lines.push(`  Source: ${dependency.homepage}`);
    }

    return lines.join('\n');
  })
  .join('\n\n');

const noticePath = path.join(repoRoot, 'NOTICE');
await fs.writeFile(noticePath, `${noticeHeader}${noticeBody}\n`, 'utf8');

console.log(`Wrote NOTICE to ${path.relative(projectRoot, noticePath)}`);
console.log(`Wrote license inventory to ${path.relative(projectRoot, inventoryPath)}`);
